(ns aoc.day-16
  (:require [aoc.util :as util]))

(def input (util/read-input))
(def samples
  {:2-subpackets "00111000000000000110111101000101001010010001001000000000"
   :3-subpackets "11101110000000001101010000001100100000100011000001100000"
   :1-literal-packet "110100101111111000101000"})

(def hex->bin
  {"0" "0000"
   "1" "0001"
   "2" "0010"
   "3" "0011"
   "4" "0100"
   "5" "0101"
   "6" "0110"
   "7" "0111"
   "8" "1000"
   "9" "1001"
   "A" "1010"
   "B" "1011"
   "C" "1100"
   "D" "1101"
   "E" "1110"
   "F" "1111"})

(defn parse-input
  [input]
  (apply str (mapcat (comp hex->bin str) input)))

(defn take-until
  [f coll]
  (let [[left right] (split-with (complement f) coll)]
    (concat left (take 1 right))))

(defn parse-literal
  [s]
  (let [consumed (->> (partition 5 s)
                      (take-until #(= \0 (first %))))
        remainder (apply str (drop (->> (map count consumed)
                                        (reduce +))
                                   s))]
    [{:packet/literal-value (-> (->> consumed
                                     (mapcat next)
                                     (apply str))
                                (Long/valueOf 2))}
     remainder]))

(declare parse-packet)

(defn parse-subpacket
  [state]
  ;(pprint/pprint state)
  (let [[subpackets remainder] state]
    (when-let [subpacket (parse-packet remainder)]
      (update subpacket 0 #(conj subpackets %)))))

(defn parse-op-type-0
  [s]
  ;(prn "parse-type-0" s)
  (let [n-subpacket-bits (-> (apply str (take 15 s))
                             (Long/valueOf 2))
        remainder (apply str (->> s
                                  (drop 15)
                                  (drop n-subpacket-bits)))
        [subpackets _zero-remainder] (->> (iterate parse-subpacket [[] (take n-subpacket-bits (drop 15 s))])
                                          (take-while some?)
                                          (last))]
    #_(prn {:packet/n-subpacket-bits n-subpacket-bits
            :some-type-0-bits        (apply str (take 10 remainder))
            :size-bits (apply str (take 15 s))
            :s                       (apply str s)
            :remaining-bits (count remainder)
            :zero-remainder zero-remainder})
    [{:packet/n-subpacket-bits n-subpacket-bits
      :packet/subpackets       subpackets}
     remainder]))

(defn parse-op-type-1
  [s]
  (let [n-subpackets (-> (apply str (take 11 s))
                         (Long/valueOf 2))
        [subpackets remainder] (->> (iterate parse-subpacket [[] (apply str (drop 11 s))])
                                    (take (inc n-subpackets))
                                    (last))]
    #_(prn {:packet/n-subpackets n-subpackets
            :size-bits (apply str (take 11 s))})
    [{:packet/n-subpackets n-subpackets
      :packet/subpackets subpackets}
     (apply str remainder)]))

(defn parse-operator
  [s]
  (let [length-type (first s)]
    ;(prn {:length-type length-type})
    (update
      (case length-type
        \0 (parse-op-type-0 (next s))
        \1 (parse-op-type-1 (next s)))
      0
      assoc
      :packet/length-type length-type)))

(defn packet-parser
  [type]
  (case type
    "100" parse-literal
    parse-operator))

(defn parse-header
  [bin-str]
  (let [version (apply str (take 3 bin-str))
        packet-type (apply str (take 3 (drop 3 bin-str)))]
    #_(prn {:packet/version version
            :packet/type    packet-type
            :remaining-bits (count (drop 6 bin-str))})
    [{:packet/version version
      :packet/type    packet-type}
     (apply str (drop 6 bin-str))]))

(defn parse-contents
  [[header remainder]]
  (-> ((packet-parser (:packet/type header)) remainder)
      (update 0 merge header)))

(defn parse-packet
  [bin-str]
  ;(prn "parse-packet" (apply str bin-str))
  (when (seq bin-str)
    (parse-contents (parse-header bin-str))))

(defn split-into-sizes
  [sizes coll]
  (if (seq sizes)
    (cons (take (first sizes) coll)
          (split-into-sizes (rest sizes) (drop (first sizes) coll)))
    (list coll)))

(defn versions
  [packet-tree]
  (when (seq packet-tree)
    (cons (:packet/version packet-tree)
          (mapcat versions (:packet/subpackets packet-tree)))))

(defn part-1
  []
  (->> (versions (first (parse-packet (parse-input input))))
       (map #(Long/valueOf % 2))
       (reduce +)))

(comment
  (parse-packet (:1-literal-packet samples))
  (parse-packet (:2-subpackets samples))
  (versions (first (parse-packet (:3-subpackets samples))))
  (parse-packet (parse-input input))
  (parse-packet "110100101111111000101000")
  (parse-packet "100010100000000001001100101111010111000111101100001010110010000000000011000000010010001000011001000100000010010100110110010111100000000000001111100011000011100010010110111111101110100111011010111001110010110101100100000000000100000101001000100101001001100000000010100110100000000010111100101101001110010111000100111010010110100111001011100010010111001011011001100001101111001001101000001000000000111100011000000000111011000001011110001110110100000100000011000000000110101000101100110000110101100000110010010000000000100001010100011110011000101011110001011101001100000000010001111100000000010000100111000110110010011001101010010101110011100111111001110111101100001110100110000000010011010011111010010001001101000110100100101010010010010010101010110100111000000001010101001001011010110001010111111000100001000110101010010110000011011001111100100101100100101011110110101011111111010111001011100010101000100000000001010100001001000010000000010011001111000100000000011000100011101001000110010010001011111000100000000011110100011010111000111100110000100100000100000000011000100001010001000111111110000111010001100000000010001100101001010010011100110001001011110000000001010010011101111111011110101111101011001100101100100100001101100010000000000110001010000000000101000000000001011111110100100000000101101001111010000000010101001110001000000001001111011100110000000100100111101011000000010001000110001110000000000111100000000000111010011100011000000000010010101000000000010010110000000010101111110011000000001001100100100110000000000110100110000000000111101010000000000110001110000000000111101110000000000101000100000000001010011101001101111000111011011110111100010110101000110000000001010011010000000001010110011011111000100101110011110100001110010101100001110010001001100101001011111111100001011111110110001000101101100001100000000010001110100000000010001100110001001010111100110111101110011000100101011110011011110001001011110111100000111011101110000000001110010010110111001111100101011100011110001001100011111001100110011000000000101011101000000000101101001101001111111100100101110111111101011001110111100100010100010000110011001100000000010011101000000000011010010110011011111001100001111100100100111100010000000101101001100011000101101011011001101111111111101100010001110101100000000011010001101001010111111000000011001101010001101101010101111001100100100010110110011100111001001110011111010000111010010110111111001110000111101101110011101001111100101000010100000000101100100101111100010101000110011001110010100001101101001100100111000100101001110110001000001101000001101000100000000001000001011001100101001001100110100110001100010000000010110110010001110011110100101111100100111110010010111110100000110011000111001100000101101100011101011001000111100010100101000001001010010100111001101110100100111000111101000111100010000000010101110000101000000000110101010100000000000001000010001000110011110001110100100010100010001000000000110111000011110010001110110100010010011001000110101100001011111001110101110101111111001000000001010111010110010101101101001010000101011110110010001111011101000000000101000000000000000100001110100001000111000101010110000110000000000000000010000101110001101100100010011001000100000101000000000010010100111001111010111100010011100010011010101010011100010010010000001011000110000000110000000001001010011100011101001010000000001100110001000100000000011011100011010111000010101110000011101000100000000011101100011100011000100001110000101011011000000000010010101010011000010010111001101010110010101101001000111000111111110100111011001000000000101011011010110000000001001010011001110101001100001100100110011101010011000010101001110100111110011100000000001111100101011101111000110000100110001000000000001111101111001001011110110011110010110101011001011010000001101000000110110011000000101110010000000001101001000110000000000010111110110010011110101101011000011011101001000100010001100101001000010111111011001100110101001100000000010010100110001100111101011100101010000000000100101011100010011011001010110111100100000001000100000000010110111011001111010101101101010001100001110100000000010110100100111100011111000000111001011101010001001000000000100110011010010100001100011011000000000100101001111110000000011101001111110000000010110010000000010010001011100111011010101101000111100000000010000000100000000011001100000111111000101011110001011011000000000000010000110010000011100100010110001000001011100110000000001011111110000000001001110010110010111111001011001011011100110001100111011101001011010101101111000101110011100100011111000010000001100000000101001100100010111110010011110001110001001101101000011100100010111100110010010011110100011000000000100111100000000001101010001000100000000011001100001000011000110010110001010001000000000000010000100110000101001100010011101000010101110011001111011110100000111000000000000011000000110000101010100101101110000111001100110110111000000110000000001111010011001011001001001010101000101100101010000101110001010101100110100110010000100000000011010010111001101101000000101000000000100001111010011000110011111001100011100101101111110101111001110111000010100")
  (map #(apply str %)
       (split-into-sizes
         [3 3 1 15 3 3 5 3 3 5 5]
         "00111000000000000110111101000101001010010001001000000000")))
